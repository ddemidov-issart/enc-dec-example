package com.gitkraken.decryption;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.PGPCompressedData;
import org.bouncycastle.openpgp.PGPEncryptedDataList;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPLiteralData;
import org.bouncycastle.openpgp.PGPPrivateKey;
import org.bouncycastle.openpgp.PGPPublicKeyEncryptedData;
import org.bouncycastle.openpgp.PGPSecretKey;
import org.bouncycastle.openpgp.PGPSecretKeyRing;
import org.bouncycastle.openpgp.PGPSecretKeyRingCollection;
import org.bouncycastle.openpgp.PGPUtil;
import org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;
import org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;
import org.bouncycastle.openpgp.operator.PublicKeyDataDecryptorFactory;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcePublicKeyDataDecryptorFactoryBuilder;
import org.bouncycastle.util.io.Streams;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.Security;
import java.util.Objects;

/**
 * Based on https://github.com/bcgit/bc-java/blob/main/pg/src/main/java/org/bouncycastle/openpgp/examples/PBEFileProcessor.java
 */
public class App {

    public static final String INPUT_FILE_NAME = "encrypted-data.bpg";
    public static final String OUTPUT_FILE_NAME = "decrypted-data.txt";
    public static final String PRIVATE_KEY = "/private.key";
    public static final String PASS_PHRASE = "password";

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static void main(String[] args) throws Exception {
        PGPPrivateKey privateKey = loadPrivateKey(PRIVATE_KEY, PASS_PHRASE);
        try (InputStream in = Files.newInputStream(Paths.get(INPUT_FILE_NAME))) {
            decryptFile(in, privateKey);
        }
    }

    private static void decryptFile(InputStream in, PGPPrivateKey privateKey) throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(in);
        PGPEncryptedDataList enc;
        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }

        PGPPublicKeyEncryptedData pbe = (PGPPublicKeyEncryptedData) enc.get(0);
        if (!pbe.isIntegrityProtected()) {
            throw new PGPException("Message is not integrity protected!");
        }

        PublicKeyDataDecryptorFactory decryptorFactory = new JcePublicKeyDataDecryptorFactoryBuilder()
                .setProvider(BouncyCastleProvider.PROVIDER_NAME)
                .build(privateKey);

        InputStream clear = pbe.getDataStream(decryptorFactory);
        pgpF = new JcaPGPObjectFactory(clear);

        //
        // if we're trying to read a file generated by someone other than us
        // the data might not be compressed, so we check the return type from
        // the factory and behave accordingly.
        //
        o = pgpF.nextObject();
        if (o instanceof PGPCompressedData) {
            PGPCompressedData cData = (PGPCompressedData) o;
            pgpF = new JcaPGPObjectFactory(cData.getDataStream());
            o = pgpF.nextObject();
        }

        PGPLiteralData ld = (PGPLiteralData) o;
        InputStream unc = ld.getInputStream();

        try (OutputStream fOut = Files.newOutputStream(Paths.get(ld.getFileName()))) {
            Streams.pipeAll(unc, fOut, 8192);
        }

        if (pbe.isIntegrityProtected() && pbe.verify()) {
            System.err.println("message integrity check passed");
        } else {
            System.err.println("message failed integrity check");
        }
    }

    public static PGPPrivateKey loadPrivateKey(String privateKeyFileResource, String passphrase) throws Exception {
        PGPSecretKeyRingCollection keyRingCollection = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(Objects.requireNonNull(
                        App.class.getResourceAsStream(privateKeyFileResource)
                )),
                new JcaKeyFingerprintCalculator()
        );
        for (PGPSecretKeyRing keyRing : keyRingCollection) {
            for (PGPSecretKey secretKey : keyRing) {
                if (secretKey.isSigningKey()) {
                    PBESecretKeyDecryptor decryptorFactory = new JcePBESecretKeyDecryptorBuilder()
                            .setProvider(BouncyCastleProvider.PROVIDER_NAME)
                            .build(passphrase.toCharArray());
                    return secretKey.extractPrivateKey(decryptorFactory);
                }
            }
        }
        throw new IllegalArgumentException("No signing key found in the provided private key file.");
    }
}
