package com.gitkraken.decryption;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.PGPCompressedData;
import org.bouncycastle.openpgp.PGPEncryptedData;
import org.bouncycastle.openpgp.PGPEncryptedDataList;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPLiteralData;
import org.bouncycastle.openpgp.PGPOnePassSignatureList;
import org.bouncycastle.openpgp.PGPPrivateKey;
import org.bouncycastle.openpgp.PGPPublicKeyEncryptedData;
import org.bouncycastle.openpgp.PGPSecretKey;
import org.bouncycastle.openpgp.PGPSecretKeyRing;
import org.bouncycastle.openpgp.PGPSecretKeyRingCollection;
import org.bouncycastle.openpgp.PGPUtil;
import org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;
import org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;
import org.bouncycastle.openpgp.operator.PublicKeyDataDecryptorFactory;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcePublicKeyDataDecryptorFactoryBuilder;
import org.bouncycastle.util.io.Streams;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.NoSuchProviderException;
import java.security.Security;
import java.util.Iterator;
import java.util.Objects;

/**
 * Based on https://github.com/bcgit/bc-java/blob/main/pg/src/main/java/org/bouncycastle/openpgp/examples/PBEFileProcessor.java
 */
public class App {

    public static final String INPUT_FILE_NAME = "encrypted-data.bpg";
    public static final String OUTPUT_FILE_NAME = "decrypted-data.txt";
    public static final String PRIVATE_KEY = "/private.key";
    public static final String PASS_PHRASE = "password";

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static void main(String[] args) throws Exception {
        decryptFile(INPUT_FILE_NAME, "private.key", PASS_PHRASE.toCharArray(), OUTPUT_FILE_NAME, true);

//        PGPPrivateKey privateKey = loadPrivateKey(PRIVATE_KEY, PASS_PHRASE);
//        try (InputStream in = Files.newInputStream(Paths.get(INPUT_FILE_NAME))) {
//            decryptFile(in, privateKey);
//        }
    }

    private static void decryptFile(InputStream in, PGPPrivateKey privateKey) throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(in);
        PGPEncryptedDataList enc;
        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }
        Iterator<PGPEncryptedData> it = enc.getEncryptedDataObjects();

        PGPPublicKeyEncryptedData pbe = (PGPPublicKeyEncryptedData) enc.get(0);
        if (!pbe.isIntegrityProtected()) {
            throw new PGPException("Message is not integrity protected!");
        }

        PublicKeyDataDecryptorFactory decryptorFactory = new JcePublicKeyDataDecryptorFactoryBuilder()
                .setProvider(BouncyCastleProvider.PROVIDER_NAME)
                .build(privateKey);

        InputStream clear = pbe.getDataStream(decryptorFactory);
        pgpF = new JcaPGPObjectFactory(clear);

        //
        // if we're trying to read a file generated by someone other than us
        // the data might not be compressed, so we check the return type from
        // the factory and behave accordingly.
        //
        o = pgpF.nextObject();
        if (o instanceof PGPCompressedData) {
            PGPCompressedData cData = (PGPCompressedData) o;
            pgpF = new JcaPGPObjectFactory(cData.getDataStream());
            o = pgpF.nextObject();
        }

        PGPLiteralData ld = (PGPLiteralData) o;
        InputStream unc = ld.getInputStream();

        try (OutputStream fOut = Files.newOutputStream(Paths.get(ld.getFileName()))) {
            Streams.pipeAll(unc, fOut, 8192);
        }

        if (pbe.isIntegrityProtected() && pbe.verify()) {
            System.err.println("message integrity check passed");
        } else {
            System.err.println("message failed integrity check");
        }
    }

    public static PGPPrivateKey loadPrivateKey(String privateKeyFileResource, String passphrase) throws Exception {
        PGPSecretKeyRingCollection keyRingCollection = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(Objects.requireNonNull(
                        App.class.getResourceAsStream(privateKeyFileResource)
                )),
                new JcaKeyFingerprintCalculator()
        );
        for (PGPSecretKeyRing keyRing : keyRingCollection) {
            for (PGPSecretKey secretKey : keyRing) {
                if (secretKey.isSigningKey()) {
                    PBESecretKeyDecryptor decryptorFactory = new JcePBESecretKeyDecryptorBuilder()
                            .setProvider(BouncyCastleProvider.PROVIDER_NAME)
                            .build(passphrase.toCharArray());
                    return secretKey.extractPrivateKey(decryptorFactory);
                }
            }
        }
        throw new IllegalArgumentException("No signing key found in the provided private key file.");
    }

    public static void decryptFile(String encryptedInputFileName, String privatekeyFileName, char[] passPhrase, String defaultFileName, boolean withIntegrityCheck) throws IOException, NoSuchProviderException {
        InputStream instream = new BufferedInputStream(new FileInputStream(encryptedInputFileName));
        InputStream privateKeyInStream = new BufferedInputStream(new FileInputStream(privatekeyFileName));
        instream = PGPUtil.getDecoderStream(instream);

        try {
            JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(instream);
            PGPEncryptedDataList enc;
            Object o = pgpF.nextObject();
            // the first object might be a PGP marker packet.
            if (o instanceof PGPEncryptedDataList) {
                enc = (PGPEncryptedDataList) o;
            } else {
                enc = (PGPEncryptedDataList) pgpF.nextObject();
            }
            Iterator it = enc.getEncryptedDataObjects();
            PGPPrivateKey sKey = null;
            PGPPublicKeyEncryptedData pbe = null;
            PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(PGPUtil.getDecoderStream(privateKeyInStream), new JcaKeyFingerprintCalculator());
            while (sKey == null && it.hasNext()) {
                pbe = (PGPPublicKeyEncryptedData) it.next();
                sKey = PGPExampleUtil.findSecretKey(pgpSec, pbe.getKeyID(), passPhrase);
            }
            if (sKey == null) {
                throw new IllegalArgumentException("secret key for message not found.");
            }
            InputStream clear = pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider("BC")
                    .build(sKey));
            JcaPGPObjectFactory plainFact = new JcaPGPObjectFactory(clear);
            Object message = plainFact.nextObject();
            if (message instanceof PGPCompressedData) {
                PGPCompressedData cData = (PGPCompressedData) message;
                JcaPGPObjectFactory pgpFact = new JcaPGPObjectFactory(cData.getDataStream());
                message = pgpFact.nextObject();
            }
            if (message instanceof PGPLiteralData) {
                PGPLiteralData ld = (PGPLiteralData) message;
                InputStream unc = ld.getInputStream();
                OutputStream fOut = new FileOutputStream(defaultFileName);
                Streams.pipeAll(unc, fOut);
                fOut.close();
            } else if (message instanceof PGPOnePassSignatureList) {
                throw new PGPException("encrypted message contains a signed message - not literal data.");
            } else {
                throw new PGPException("message is not a simple encrypted file - type unknown.");
            }
            if (pbe.isIntegrityProtected() && pbe.verify()) {
                System.err.println("message integrity check passed");
            } else {
                System.err.println("message integrity check failed");
            }
        } catch (PGPException e) {
            System.err.println(e.getMessage());
        }
        privateKeyInStream.close();
        instream.close();
    }
}
